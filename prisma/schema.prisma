// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String  @id @default(uuid())
  name          String
  email         String  @unique
  emailVerified Boolean @default(false)
  image         String?

  areaId      String?
  phoneNumber String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  area area? @relation(fields: [areaId], references: [id])

  sessions      Session[]
  accounts      Account[]
  cart          Cart[]
  order         Order[]
  RefundRequest RefundRequest[]
  role           Role            @default(USER)

  // feedback_request feedback_request[]
  feedback       feedback[]
  paymentIntents PaymentIntent[]

  @@map("user")
}

enum Role {
  USER
  ADMIN
}

model Session {
  id        String   @id @default(uuid())
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id @default(uuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id @default(uuid())
  identifier String   @unique
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model TeffType {
  id       String        @id @default(uuid())
  name     String        @unique
  products TeffProduct[]
}

model TeffQuality {
  id       String        @id @default(uuid())
  name     String        @unique // "Level 1", "Level 2"
  products TeffProduct[]
}

model Image {
  id        String      @id @default(uuid())
  url       String
  productId String
  product   TeffProduct @relation(fields: [productId], references: [id])
}

// model Packaging {
//   id      String @id @default(uuid())
//   sizeKg  Int    @unique
//   carts   Cart[]
//   orderItems OrderItem[]
// }

model TeffProduct {
  id          String       @id @default(uuid())
  name        String
  description String?
  pricePerKg  Float
  teffTypeId  String
  qualityId   String?
  teffType    TeffType     @relation(fields: [teffTypeId], references: [id])
  quality     TeffQuality? @relation(fields: [qualityId], references: [id])
  images      Image[]
  cartItems   Cart[]
  orderItems  OrderItem[]
  feedback    feedback[]
  discount    Float? // discount percentage
  inStock     Boolean      @default(true)
  orderCount  Int          @default(0)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

enum OrderStatus {
  PENDING_PAYMENT
  TO_BE_DELIVERED // Order is ongoing (payment or delivery)
  COMPLETED // Delivered & confirmed
  CANCELLED // Cancelled or declined
}

enum PaymentStatus {
  PENDING // No payment yet
  SCREENSHOT_SENT // Screenshot uploaded, waiting admin
  FAILED // Online payment failed
  CONFIRMED // Admin or webhook confirmed payment
  DECLINED // Screenshot rejected
  REFUNDED // Money refunded
}

enum DeliveryStatus {
  NOT_SCHEDULED
  SCHEDULED
  DELIVERED
}

model Order {
  id             String @id @default(uuid())
  merchOrderId   String @unique
  idempotencyKey String @unique

  userId String
  user   User   @relation(fields: [userId], references: [id])

  status         OrderStatus    @default(PENDING_PAYMENT)
  paymentStatus  PaymentStatus  @default(PENDING)
  deliveryStatus DeliveryStatus @default(NOT_SCHEDULED)

  totalAmount Float
  phoneNumber String

  orderrecived         String // delivery | pickup
  paymentMethod        String // chapa | telebirr | screenshot
  paymentProofUrl      String? // screenshot image
  paymentDeclineReason String?

  areaId String
  area   area   @relation(fields: [areaId], references: [id])

  totalDeliveryFee   Int
  extraDeliveryFee   Int                 @default(0)
  extraDistanceLevel ExtraDistanceLevel?

  deliveryDate DateTime?

  Refundstatus RefundStatus @default(Not_Started)
  cancelReason String?
  refundAmount Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  refundRequests      RefundRequest[]
  items               OrderItem[]
  paymentIntents      PaymentIntent[]
  paymentTransactions PaymentTransaction[]
  orderTrackings      OrderTracking[]

  @@index([status, createdAt])
  @@index([paymentStatus])
  @@index([deliveryStatus])
}

enum ExtraDistanceLevel {
  near
  medium
  far
}

enum TrackingType {
  PAYMENT_SUBMITTED
  PAYMENT_CONFIRMED
  DELIVERY_SCHEDULED
  CONFIRMED
  CANCELLED
  REFUNDED
}

model OrderTracking {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  type      TrackingType
  title     String // "Payment Confirmed"
  message   String? // optional admin note
  timestamp DateTime? // set when event occurs

  createdAt DateTime @default(now())

  // @@unique([orderId])
  @@index([orderId, type]) // keep index for queries
}

model OrderItem {
  id        String      @id @default(uuid())
  orderId   String
  productId String
  packaging Int         @default(1)
  quantity  Int
  price     Float
  order     Order       @relation(fields: [orderId], references: [id])
  product   TeffProduct @relation(fields: [productId], references: [id])
  // packaging    Packaging     @relation(fields: [packagingId], references: [id])

  @@index([orderId])
}

enum feedback_status {
  pending
  notified
  completed
  cancelled
}

enum RefundStatus {
  Not_Started
  PENDING // User requested refund
  APPROVED // Admin approved refund
  REJECTED // Admin rejected refund
}

model RefundRequest {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  accountName   String
  accountNumber String?
  phoneNumber   String?
  reason        String?

  status    RefundStatus @default(Not_Started)
  adminNote String? // Optional note if rejected/approved

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// model feedback_request {
//   id                 String          @id @default(uuid())
//   orderId            String          @unique
//   userId             String
//   status             feedback_status @default(pending)
//   feedback_submitted Boolean         @default(false)
//   skip_count         Int             @default(0)
//   price              Float
//   notifiedAt         DateTime?
//   createdAt          DateTime        @default(now())
//   updatedAt          DateTime        @updatedAt

//   order Order @relation(fields: [orderId], references: [id])
//   user  User  @relation(fields: [userId], references: [id])

//   @@index([status, createdAt])
// }

model feedback {
  id          String    @id @default(uuid())
  userId      String
  productid   String
  rating      Int?
  message     String?
  submittedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user              User                @relation(fields: [userId], references: [id])
  teffproduct       TeffProduct         @relation(fields: [productid], references: [id])
  feedbackanalytics FeedbackAnalytics[]

  @@unique([userId, productid])
  @@index([productid])
}

model FeedbackAnalytics {
  id          String  @id @default(uuid())
  teffTypeId  String
  qualityId   String?
  packagingId String?
  feedbackId  String
  rating      Int

  feedback feedback @relation(fields: [feedbackId], references: [id])

  @@index([teffTypeId, qualityId, packagingId])
}

model area {
  id        String   @id @default(uuid())
  name      String
  baseFee   Int
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  orders    Order[]
  users     User[]
}

model deliveryconfigration {
  id             String   @id @default(uuid())
  key            String   @unique
  feePerKg       Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model AppSettings {
  id           String   @id @default(uuid())
  key          String   @unique @default("default")
  companyName  String?
  description  String?
  logoUrl      String?
  email        String?
  phone        String?
  address      String?
  facebookUrl  String?
  instagramUrl String?
  twitterUrl   String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("app_settings")
}

model Cart {
  id        String      @id @default(uuid())
  userId    String
  productId String
  quantity  Int         @default(1)
  packaging Int         @default(1) // e.g. 5, 10, 15 (kg)
  product   TeffProduct @relation(fields: [productId], references: [id])
  user      User        @relation(fields: [userId], references: [id])
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@unique([userId, productId, packaging]) // ðŸ‘ˆ prevents duplicates for same size
}

//for feedback i want is after a user order completed it will send notification for user 

// enum paymentstatus {
//   PENDING
//   PAID
//   FAILED

// }

model PaymentIntent {
  id             String   @id @default(uuid())
  orderId        String   @unique
  userId         String
  amount         Float
  currency       String   @default("ETB")
  method         String
  status         String   @default("PENDING")
  providerId     String?
  clientSecret   String?
  metadata       Json     @default("{}")
  idempotencyKey String?  @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  order        Order                @relation(fields: [orderId], references: [id])
  user         User                 @relation(fields: [userId], references: [id])
  transactions PaymentTransaction[]

  @@index([userId])
  @@index([orderId])
  @@index([providerId])
  @@index([idempotencyKey])
}

// -------------------- Payment Transactions --------------------
model PaymentTransaction {
  id              String   @id @default(uuid())
  orderId         String   @unique
  paymentIntentId String?
  provider        String
  providerRef     String?
  amountCents     Int
  currency        String   @default("ETB")
  status          String
  rawPayload      Json?
  type            String   @default("CAPTURE")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  idempotencyKey  String?

  order         Order          @relation(fields: [orderId], references: [id])
  paymentIntent PaymentIntent? @relation(fields: [paymentIntentId], references: [id])

  @@index([orderId])
  @@index([provider, providerRef])
  @@index([paymentIntentId])
  @@index([idempotencyKey])
}

enum idempotencyKeyStatus {
  PENDING
  SUCCESS
  FAILURE
}

// -------------------- Idempotency Keys --------------------
model IdempotencyKey {
  id           String               @id @default(uuid())
  key          String
  operation    String
  requestHash  String
  responseData Json?
  status       idempotencyKeyStatus @default(PENDING) // PENDING | SUCCEEDED | FAILED
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  expiresAt    DateTime

  @@unique([key, operation])
  @@index([expiresAt])
  @@index([status])
}

// payment model can be added later when integrating payment gateway

/**
 * model Payment_initent {
 * id            String     @id @default(uuid())
 * orderId       String
 * amount        Float
 * currency      String
 * status        String
 * createdAt     DateTime  @default(now())
 * updatedAt     DateTime  @updatedAt
 * order         Order     @relation(fields: [orderId], references: [id])
 * }
 * // indmpotency key
 * model indempotencyKey {
 * id            String     @id @default(uuid())
 * key           String     @unique
 * createdAt     DateTime  @default(now())
 * updatedAt     DateTime  @updatedAt
 * }
 */

// enum status - status: 'pending_payment'| 'paied' | 'delivered' | 'completed' | 'cancelled' | 'refunded';
// enum Status {
//   pending
//   failed
//   paid
//   delivered
//   completed
//   cancelled
//   refunded
// }

// model Order {
//   id                 String              @id @default(uuid())
//   merchOrderId       String              @unique
//   userId             String
//   status             Status              @default(pending)
//   totalAmount        Float

//   areaId             String
//   area               area                @relation(fields: [areaId], references: [id])
//   phoneNumber        String

//   // Delivery details

//   totalDeliveryFee   Int
//   extraDeliveryFee   Int                 @default(0)
//   extraDistanceLevel ExtraDistanceLevel?

//   deliveryDate       DateTime?
//   createdAt          DateTime            @default(now())
//   updatedAt          DateTime            @updatedAt

//   // Relations
//   user               User                @relation(fields: [userId], references: [id])
//   items              OrderItem[]
//   feedback_request   feedback_request[]
//   paymentIntents     PaymentIntent[]
//   paymentTransactions PaymentTransaction[]
//   orderTrackings     OrderTracking[]

//   @@index([deliveryDate])
//   @@index([status])
// }
